# -*- coding: utf-8 -*-
"""MAS_final_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jjL6QIfiau4NtKHy6BJdxc_2mAj60hkd

# **Final Project - Car Crash Data Clustering and Regression Analysis**
By Tyler Katz

# Crash Data Upload, Cleaning and Import Packages
"""

##required packages
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.linear_model import LinearRegression

##data upload link -> https://saturncloud.io/blog/how-to-upload-csv-files-from-google-drive-into-google-colaboratory/
from google.colab import drive
drive.mount('/content/drive', force_remount = True)
df = pd.read_csv('/content/drive/My Drive/Colab Notebooks/maas4115_data.csv', encoding = 'unicode_escape')
df = df.dropna()

"""# For Future Regression (Nominal Variables)"""

##print the unique column values for the columns to use
print(df['Collision Type'].unique())
print(df['Primary Factor'].unique())

##display frequencies of values for better understanding
df['Collision Type'].value_counts().plot(kind = 'bar')
plt.title('Collision Type Frequency')
plt.xlabel('Collision Type')
plt.ylabel('Frequency')
plt.show()
df['Primary Factor'].value_counts().plot(kind = 'barh')
plt.yticks(fontsize = 5)
plt.title('Primary Factor Frequency')
plt.ylabel('Primary Factor')
plt.xlabel('Frequency')
plt.figure(figsize = (100, 100))
plt.show()

"""# Regression Functions"""

##functions
def fit_regression_line(x, y):
  x = x.reshape(-1, 1)
  model = LinearRegression()
  model.fit(x, y)
  slope = model.coef_[0]
  intercept = model.intercept_
  return slope, intercept

def plot_regression_line(data):
  plt.figure(figsize=(10, 6))
  slope, intercept = fit_regression_line(x, y)

  regression_line = slope * x + intercept
  plt.scatter(x, y, label='Data Points')
  plt.plot(x, regression_line, color='red', label='Regression Line')

  error = np.mean((regression_line - y)**2) #####error: in practice it should be actual - predicted
  plt.title(f'Linear Regression Line\nMean Squared Error: {error:.2f}')
  plt.xlabel('X')
  plt.ylabel('Y')
  plt.legend()
  plt.grid(True)
  plt.show()

##create a function to compute mean squared error
def mse(x, y, slope, intercept):
  ##calculate predicted y based on regression line
  y_hat = slope * x + intercept
  ##calculate residuals
  errors = y - y_hat
  ##calculate mean of squared errors
  return np.mean(errors ** 2)

"""# Simple Linear Regression on Primary Factor vs Collision Type (Poor Relationship)"""

##use a map to correspond most frequent values to number
collision_ints = df['Collision Type'].value_counts()
map = {}
count = 1

for type in collision_ints.index:
  map[type] = count
  count += 1

##create new column corresponding to map values
df['Collision Ints'] = df['Collision Type'].apply(lambda x: map[x])

##repeat for primary factor
primary_factor_ints = df['Primary Factor'].value_counts()
map1 = {}
count1 = 1

for type in primary_factor_ints.index:
  map1[type] = count1
  count1 += 1

df['Primary Factor Ints'] = df['Primary Factor'].apply(lambda x: map1[x])

x = df['Collision Ints'].values
y = df['Primary Factor Ints'].values

print(f"Size of x matrix: {df['Collision Ints'].count()}") ##size of x matrix
print(f"Size of y matrix: {df['Primary Factor Ints'].count()}") ##size of y matrix
print(fit_regression_line(x, y))
plot_regression_line(pd.DataFrame({'Collision Ints': x, 'Primary Factor Ints': y}))

"""# K-Means Initialization on Previous Data"""

##run k-means on the dataset with k = 8
K_df = df[['Collision Ints', 'Primary Factor Ints']].values
k_means = KMeans(n_clusters = 8)
k_means.fit(K_df)
centroids = k_means.cluster_centers_
count = 1

##plot the distances to the cluster centers
plt.figure(figsize = (12, 6))
for centroid in centroids:
  ##calculate euclidean distance to each centroid
  dists = np.linalg.norm(K_df - centroid, axis = 1)
  ##find nearest 50000 nearest points since the data set is large
  nearest_indices = dists.argsort()[:50000]

  ##plot the data with respect to each centroid
  plt.subplot(2, 4, count)
  plt.scatter(K_df[nearest_indices, 0], K_df[nearest_indices, 1], color = 'red', label = 'Nearest Points')
  plt.scatter(centroid[0], centroid[1], color = 'green', s = 100, label= 'Centroid')
  plt.title(f'Centroid {count}')
  plt.xlabel('Collision Ints')
  plt.ylabel('Primary Factor Ints')
  plt.legend()
  count += 1

plt.tight_layout()

"""# Linear Regression on Each Cluster"""

for i in range(8):
  ##points in each cluster
  points = K_df[k_means.labels_ == i]

  slope, intercept = fit_regression_line(points[:, 0], points[:, 1])
  ##print the regression slope and intercept for each cluster
  print(f'Cluster {i + 1} = {slope, intercept}')
  print(f'Mean Squared Error: {mse(points[:, 0], points[:, 1], slope, intercept)}')
  print()

"""# Repeat Previous K-Means with Different K"""

##run k-means on the dataset with k = 20, may take a while
K_df1 = df[['Collision Ints', 'Primary Factor Ints']].values
k_means1 = KMeans(n_clusters = 20)
k_means1.fit(K_df1)
centroids1 = k_means1.cluster_centers_
count = 1

##plot the distances to the cluster centers
plt.figure(figsize = (15, 15))
for centroid in centroids1:
  ##calculate euclidean distance to each centroid
  dists = np.linalg.norm(K_df1 - centroid, axis = 1)
  ##find nearest 50000 nearest points since the data set is large
  nearest_indices = dists.argsort()[:50000]

  ##clean up the plots
  plt.subplot(4, 5, count)
  plt.scatter(K_df1[nearest_indices, 0], K_df1[nearest_indices, 1], color = 'red', label = 'Nearest Points')
  plt.scatter(centroid[0], centroid[1], color = 'green', s = 100, label= 'Centroid')
  plt.title(f'Centroid {count}')
  plt.xlabel('Collision Ints')
  plt.ylabel('Primary Factor Ints')
  plt.legend(loc = 'best')
  count += 1

plt.tight_layout()

"""# More Linear Regression"""

for i in range(20):
  ##points in each cluster
  points1 = K_df1[k_means1.labels_ == i]

  slope1, intercept1 = fit_regression_line(points1[:, 0], points1[:, 1])
  ##print the regression slope and intercept for each cluster
  print(f'Cluster {i + 1} = {slope1, intercept1}')
  print(f'Mean Squared Error: {mse(points1[:, 0], points1[:, 1], slope1, intercept1)}')
  print()